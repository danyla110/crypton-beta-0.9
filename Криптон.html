<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#667eea">
    <title>–ö—Ä–∏–ø—Ç–æ–Ω</title>
    <style>
        * {
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            -webkit-tap-highlight-color: transparent;
        }
        html {
            overflow-x: hidden;
        }
        body {
            max-width: 900px;
            margin: 0 auto;
            padding: 20px;
            padding-left: max(20px, env(safe-area-inset-left));
            padding-right: max(20px, env(safe-area-inset-right));
            padding-bottom: max(20px, env(safe-area-inset-bottom));
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            min-height: 100vh;
            min-height: -webkit-fill-available;
            overflow-x: hidden;
        }
        h1 {
            color: white;
            text-align: center;
            margin-bottom: 30px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.3);
            font-size: clamp(1.25rem, 5vw, 1.75rem);
            padding-top: env(safe-area-inset-top, 0);
        }
        .container {
            background-color: white;
            border-radius: 12px;
            padding: 25px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            margin-bottom: 25px;
            transition: transform 0.2s ease;
        }
        @media (hover: hover) {
            .container:hover {
                transform: translateY(-2px);
            }
        }
        .form-group {
            margin-bottom: 20px;
        }
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #2c3e50;
        }
        textarea, input[type="text"], input[type="file"] {
            width: 100%;
            padding: 14px 12px;
            border: 2px solid #e1e8ed;
            border-radius: 8px;
            font-size: 16px; /* 16px –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ—Ç –∑—É–º –ø—Ä–∏ —Ñ–æ–∫—É—Å–µ –Ω–∞ iOS */
            transition: border-color 0.3s;
            -webkit-appearance: none;
            touch-action: manipulation;
        }
        textarea:focus, input[type="text"]:focus, input[type="file"]:focus {
            border-color: #3498db;
            outline: none;
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
        }
        textarea {
            min-height: 100px;
            resize: vertical;
            font-family: monospace;
        }
        .btn {
            background-color: #3498db;
            color: white;
            border: none;
            padding: 14px 20px;
            min-height: 48px;
            min-width: 44px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            margin-right: 10px;
            margin-bottom: 10px;
            transition: all 0.3s;
            font-weight: 600;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            user-select: none;
        }
        @media (hover: hover) {
            .btn:hover {
                background-color: #2980b9;
                transform: translateY(-1px);
                box-shadow: 0 4px 8px rgba(0,0,0,0.2);
            }
        }
        .btn:active {
            transform: scale(0.98);
        }
        .btn-danger {
            background-color: #e74c3c;
        }
        .btn-danger:hover {
            background-color: #c0392b;
        }
        .btn-success {
            background-color: #2ecc71;
        }
        .btn-success:hover {
            background-color: #27ae60;
        }
        .btn-secondary {
            background-color: #95a5a6;
        }
        .btn-secondary:hover {
            background-color: #7f8c8d;
        }
        .result-wrapper, .key-display-wrapper {
            position: relative;
        }
        .result {
            background-color: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 8px;
            padding: 50px 15px 15px 15px;
            margin-top: 10px;
            word-break: break-all;
            font-family: monospace;
            font-size: 13px;
            min-height: 60px;
            max-height: 200px;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
        }
        .copy-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255,255,255,0.95);
            border: 2px solid #ddd;
            border-radius: 8px;
            padding: 10px 14px;
            min-height: 44px;
            font-size: 14px;
            cursor: pointer;
            touch-action: manipulation;
            -webkit-tap-highlight-color: transparent;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        @media (hover: hover) {
            .copy-btn:hover {
                background: #f8f9fa;
            }
        }
        .key-info {
            font-size: 14px;
            color: #7f8c8d;
            margin-top: 5px;
        }
        .action-buttons {
            margin-top: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        .action-buttons .btn {
            flex: 1 1 auto;
            min-width: 140px;
        }
        .key-display {
            font-family: monospace;
            font-size: 12px;
            background-color: #f8f9fa;
            padding: 12px;
            border-radius: 8px;
            margin-top: 10px;
            overflow-x: auto;
            overflow-y: auto;
            white-space: pre-wrap;
            border: 1px solid #e9ecef;
            max-height: 150px;
            -webkit-overflow-scrolling: touch;
        }
        .message {
            padding: 12px 15px;
            border-radius: 6px;
            margin-bottom: 15px;
            animation: fadeIn 0.3s ease;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(-10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        .error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        .warning {
            background-color: #fff3cd;
            color: #856404;
            border: 1px solid #ffeaa7;
        }
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        .status-ready {
            background-color: #2ecc71;
        }
        .status-not-ready {
            background-color: #e74c3c;
        }
        .key-status {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            font-weight: 600;
        }
        .key-actions {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        .input-with-button {
            display: flex;
            gap: 10px;
        }
        .input-with-button textarea {
            flex: 1;
        }
        .loader {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,.3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s ease-in-out infinite;
            margin-right: 10px;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .btn:disabled {
            background-color: #bdc3c7;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        .btn:disabled:hover,
        .btn:disabled:active {
            background-color: #bdc3c7;
            transform: none;
            box-shadow: none;
        }
        .example-text {
            font-size: 14px;
            color: #7f8c8d;
            margin-top: 5px;
            font-style: italic;
        }
        .auto-copy {
            display: flex;
            align-items: center;
            margin: 10px 0;
            gap: 10px;
        }
        .auto-copy input[type="checkbox"] {
            min-width: 24px;
            min-height: 24px;
            margin: 0;
        }
        .file-input-container,
        .paste-keys-container {
            margin: 15px 0;
            padding: 15px;
            background-color: #f8f9fa;
            border-radius: 8px;
            border: 1px solid #e9ecef;
        }
        .paste-keys-container textarea {
            min-height: 80px;
        }
        .file-info {
            font-size: 14px;
            color: #7f8c8d;
            margin-top: 5px;
        }
        .hidden {
            display: none;
        }
        @media (max-width: 480px) {
            body {
                padding: 12px;
            }
            .container {
                padding: 16px;
            }
            .action-buttons .btn {
                min-width: 100%;
            }
        }
    </style>
</head>
<body>
    <h1>üîê –ö—Ä–∏–ø—Ç–æ–Ω. RSA –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ –∏ –î–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ</h1>
    
    <div class="container">
        <h2>üóùÔ∏è –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∫–ª—é—á–∞–º–∏</h2>
        <div class="key-status">
            <span id="keyStatusIndicator" class="status-indicator status-not-ready"></span>
            <span id="keyStatusText">–ö–ª—é—á–∏ –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω—ã</span>
        </div>
        
        <div class="action-buttons">
            <button id="generateKeys" class="btn">
                <span class="loader" id="generateLoader" style="display: none;"></span>
                –°–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å –Ω–æ–≤—ã–µ –∫–ª—é—á–∏
            </button>
            <button id="loadKeys" class="btn">–ó–∞–≥—Ä—É–∑–∏—Ç—å –∫–ª—é—á–∏ –∏–∑ —Ñ–∞–π–ª–∞</button>
            <button id="pasteKeys" class="btn">–í—Å—Ç–∞–≤–∏—Ç—å –∫–ª—é—á–∏ –≤—Ä—É—á–Ω—É—é</button>
            <button id="clearKeys" class="btn btn-danger">–û—á–∏—Å—Ç–∏—Ç—å –∫–ª—é—á–∏</button>
            <button id="exportKeys" class="btn btn-secondary">–≠–∫—Å–ø–æ—Ä—Ç –∫–ª—é—á–µ–π</button>
        </div>
        
        <div class="file-input-container" id="fileInputContainer" style="display: none;">
            <label for="keyFileInput">–í—ã–±–µ—Ä–∏—Ç–µ —Ñ–∞–π–ª —Å –∫–ª—é—á–∞–º–∏ (JSON):</label>
            <input type="file" id="keyFileInput" accept=".json,application/json">
            <div class="file-info">–§–∞–π–ª –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å –≤ —Ñ–æ—Ä–º–∞—Ç–µ JSON, —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∏–∑ —ç—Ç–æ–≥–æ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è</div>
        </div>
        
        <div class="paste-keys-container" id="pasteKeysContainer" style="display: none;">
            <p class="file-info">–í—Å—Ç–∞–≤—å—Ç–µ –∫–ª—é—á–∏ –≤ —Ñ–æ—Ä–º–∞—Ç–µ Base64 (PKCS8 –¥–ª—è –ø—Ä–∏–≤–∞—Ç–Ω–æ–≥–æ, SPKI –¥–ª—è –ø—É–±–ª–∏—á–Ω–æ–≥–æ):</p>
            <div class="form-group">
                <label for="pastePrivateKey">–ü—Ä–∏–≤–∞—Ç–Ω—ã–π –∫–ª—é—á (Base64):</label>
                <textarea id="pastePrivateKey" placeholder="–í—Å—Ç–∞–≤—å—Ç–µ –ø—Ä–∏–≤–∞—Ç–Ω—ã–π –∫–ª—é—á –≤ —Ñ–æ—Ä–º–∞—Ç–µ Base64..." rows="4"></textarea>
            </div>
            <div class="form-group">
                <label for="pastePublicKey">–ü—É–±–ª–∏—á–Ω—ã–π –∫–ª—é—á (Base64):</label>
                <textarea id="pastePublicKey" placeholder="–í—Å—Ç–∞–≤—å—Ç–µ –ø—É–±–ª–∏—á–Ω—ã–π –∫–ª—é—á –≤ —Ñ–æ—Ä–º–∞—Ç–µ Base64..." rows="4"></textarea>
            </div>
            <button id="applyPastedKeys" class="btn btn-success">–ü—Ä–∏–º–µ–Ω–∏—Ç—å –∫–ª—é—á–∏</button>
            <button id="cancelPasteKeys" class="btn btn-secondary">–û—Ç–º–µ–Ω–∞</button>
        </div>
        
        <div class="form-group">
            <label>üîë –ü—Ä–∏–≤–∞—Ç–Ω—ã–π –∫–ª—é—á:</label>
            <div class="key-display-wrapper">
                <div id="privateKeyDisplay" class="key-display">–ö–ª—é—á –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω</div>
                <button class="copy-btn" data-target="privateKeyDisplay">–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å</button>
            </div>
        </div>
        
        <div class="form-group">
            <label>üîì –ü—É–±–ª–∏—á–Ω—ã–π –∫–ª—é—á:</label>
            <div class="key-display-wrapper">
                <div id="publicKeyDisplay" class="key-display">–ö–ª—é—á –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω</div>
                <button class="copy-btn" data-target="publicKeyDisplay">–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å</button>
            </div>
        </div>
    </div>
    
    <div class="container">
        <h2>üîí –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è</h2>
        <div class="form-group">
            <label for="messageToEncrypt">–°–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è:</label>
            <textarea id="messageToEncrypt" placeholder="–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç –¥–ª—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è..." inputmode="text"></textarea>
            <div class="example-text">–ü—Ä–∏–º–µ—Ä: –ö–æ–Ω—Ñ–∏–¥–µ–Ω—Ü–∏–∞–ª—å–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ</div>
        </div>
        
        <div class="auto-copy">
            <input type="checkbox" id="autoCopyEncrypted" checked>
            <label for="autoCopyEncrypted">–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç –≤ –ø–æ–ª–µ –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è</label>
        </div>
        
        <button id="encryptBtn" class="btn btn-success">
            <span class="loader" id="encryptLoader" style="display: none;"></span>
            –ó–∞—à–∏—Ñ—Ä–æ–≤–∞—Ç—å
        </button>
        
        <div class="form-group">
            <label>–ó–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ (hex):</label>
            <div class="result-wrapper">
                <div id="encryptedResult" class="result">–ó–¥–µ—Å—å –±—É–¥–µ—Ç –æ—Ç–æ–±—Ä–∞–∂–µ–Ω —Ä–µ–∑—É–ª—å—Ç–∞—Ç —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è</div>
                <button class="copy-btn" data-target="encryptedResult">–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å</button>
            </div>
        </div>
    </div>
    
    <div class="container">
        <h2>üîì –î–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è</h2>
        <div class="form-group">
            <label for="messageToDecrypt">–ó–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ (hex):</label>
            <textarea id="messageToDecrypt" placeholder="–í–≤–µ–¥–∏—Ç–µ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ hex-—Ñ–æ—Ä–º–∞—Ç–µ..." inputmode="text" autocomplete="off"></textarea>
            <div class="example-text">–ü—Ä–∏–º–µ—Ä: 4a8f1e... –∏–ª–∏ h1... –¥–ª—è –≥–∏–±—Ä–∏–¥–Ω–æ–≥–æ —Ñ–æ—Ä–º–∞—Ç–∞ (hex)</div>
        </div>
        
        <button id="decryptBtn" class="btn btn-success">
            <span class="loader" id="decryptLoader" style="display: none;"></span>
            –î–µ—à–∏—Ñ—Ä–æ–≤–∞—Ç—å
        </button>
        
        <div class="form-group">
            <label>–†–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ:</label>
            <div class="result-wrapper">
                <div id="decryptedResult" class="result">–ó–¥–µ—Å—å –±—É–¥–µ—Ç –æ—Ç–æ–±—Ä–∞–∂–µ–Ω —Ä–µ–∑—É–ª—å—Ç–∞—Ç –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è</div>
                <button class="copy-btn" data-target="decryptedResult">–ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å</button>
            </div>
        </div>
    </div>
    
    <div class="container">
        <h2>üí° –°–æ–≤–µ—Ç—ã –ø–æ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é</h2>
        <ul>
            <li>–°–Ω–∞—á–∞–ª–∞ —Å–≥–µ–Ω–µ—Ä–∏—Ä—É–π—Ç–µ, –∑–∞–≥—Ä—É–∑–∏—Ç–µ –∏–ª–∏ –≤—Å—Ç–∞–≤—å—Ç–µ –∫–ª—é—á–∏ –≤—Ä—É—á–Ω—É—é</li>
            <li>–î–ª—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –ø—É–±–ª–∏—á–Ω—ã–π –∫–ª—é—á</li>
            <li>–î–ª—è –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è –ø—Ä–∏–≤–∞—Ç–Ω—ã–π –∫–ª—é—á</li>
            <li>–ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –¥–ª–∏–Ω–∞: –¥–æ 10 –ú–ë (–≥–∏–±—Ä–∏–¥–Ω–æ–µ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ AES + RSA)</li>
            <li>–ö–ª—é—á–∏ —Å–æ—Ö—Ä–∞–Ω—è—é—Ç—Å—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –≤ –≤–∞—à–µ–º –±—Ä–∞—É–∑–µ—Ä–µ</li>
            <li>–ù–µ –ø–µ—Ä–µ–¥–∞–≤–∞–π—Ç–µ –ø—Ä–∏–≤–∞—Ç–Ω—ã–π –∫–ª—é—á –¥—Ä—É–≥–∏–º –ª–∏—Ü–∞–º</li>
            <li>–≠–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–π—Ç–µ –∫–ª—é—á–∏ –¥–ª—è —Ä–µ–∑–µ—Ä–≤–Ω–æ–≥–æ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è</li>
        </ul>
    </div>
    
    <div id="messageArea"></div>

    <script>
        // –ì–ª–æ–±–∞–ª—å–Ω—ã–µ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –∫–ª—é—á–µ–π
        let cryptoKeys = null;
        let autoCopyEnabled = true;
        
        // –≠–ª–µ–º–µ–Ω—Ç—ã DOM
        const generateKeysBtn = document.getElementById('generateKeys');
        const loadKeysBtn = document.getElementById('loadKeys');
        const clearKeysBtn = document.getElementById('clearKeys');
        const exportKeysBtn = document.getElementById('exportKeys');
        const encryptBtn = document.getElementById('encryptBtn');
        const decryptBtn = document.getElementById('decryptBtn');
        const messageToEncrypt = document.getElementById('messageToEncrypt');
        const messageToDecrypt = document.getElementById('messageToDecrypt');
        const encryptedResult = document.getElementById('encryptedResult');
        const decryptedResult = document.getElementById('decryptedResult');
        const privateKeyDisplay = document.getElementById('privateKeyDisplay');
        const publicKeyDisplay = document.getElementById('publicKeyDisplay');
        const messageArea = document.getElementById('messageArea');
        const keyStatusIndicator = document.getElementById('keyStatusIndicator');
        const keyStatusText = document.getElementById('keyStatusText');
        const generateLoader = document.getElementById('generateLoader');
        const encryptLoader = document.getElementById('encryptLoader');
        const decryptLoader = document.getElementById('decryptLoader');
        const autoCopyCheckbox = document.getElementById('autoCopyEncrypted');
        const fileInputContainer = document.getElementById('fileInputContainer');
        const keyFileInput = document.getElementById('keyFileInput');
        const pasteKeysBtn = document.getElementById('pasteKeys');
        const pasteKeysContainer = document.getElementById('pasteKeysContainer');
        const pastePrivateKeyInput = document.getElementById('pastePrivateKey');
        const pastePublicKeyInput = document.getElementById('pastePublicKey');
        const applyPastedKeysBtn = document.getElementById('applyPastedKeys');
        const cancelPasteKeysBtn = document.getElementById('cancelPasteKeys');
        
        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è
        async function init() {
            setupEventListeners(); // –í—Å–µ–≥–¥–∞ –Ω–∞—Å—Ç—Ä–∞–∏–≤–∞–µ–º –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–∏
            loadTextState();
            if (!window.crypto || !window.crypto.subtle) {
                showMessage('‚ùå Web Crypto API –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞. –û—Ç–∫—Ä–æ–π—Ç–µ —Å—Ç—Ä–∞–Ω–∏—Ü—É –ø–æ HTTPS.', 'error');
                return;
            }
            await loadFromStorage(true); // –ó–∞–≥—Ä—É–∑–∏—Ç—å –∫–ª—é—á–∏ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã
            updateUI();
        }
        
        // –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤ —Å–æ–±—ã—Ç–∏–π
        function setupEventListeners() {
            generateKeysBtn.addEventListener('click', generateKeys);
            loadKeysBtn.addEventListener('click', showFileInput);
            pasteKeysBtn.addEventListener('click', showPasteKeysInput);
            applyPastedKeysBtn.addEventListener('click', applyPastedKeys);
            cancelPasteKeysBtn.addEventListener('click', hidePasteKeysInput);
            clearKeysBtn.addEventListener('click', clearKeys);
            exportKeysBtn.addEventListener('click', exportKeys);
            encryptBtn.addEventListener('click', encryptMessage);
            decryptBtn.addEventListener('click', decryptMessage);
            
            // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –≤—ã–±–æ—Ä–∞ —Ñ–∞–π–ª–∞
            keyFileInput.addEventListener('change', handleFileSelect);
            
            // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ
            autoCopyCheckbox.addEventListener('change', (e) => {
                autoCopyEnabled = e.target.checked;
            });
            
            // –ö–Ω–æ–ø–∫–∏ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è
            document.querySelectorAll('.copy-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const targetId = this.getAttribute('data-target');
                    const targetElement = document.getElementById(targetId);
                    if (!targetElement) return;
                    const text = targetElement.textContent?.trim() || '';
                    if (!text || text.startsWith('–ó–¥–µ—Å—å –±—É–¥–µ—Ç') || text === '–ö–ª—é—á –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω') {
                        showMessage('–ù–µ—Ç –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è', 'warning');
                        return;
                    }
                    copyToClipboard(text);
                    showMessage('–¢–µ–∫—Å—Ç —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω –≤ –±—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞', 'success');
                });
            });
            
            // –í–∞–ª–∏–¥–∞—Ü–∏—è hex-–≤–≤–æ–¥–∞ (–¥–æ–ø—É—Å–∫–∞–µ—Ç—Å—è –ø—Ä–µ—Ñ–∏–∫—Å "h1" –¥–ª—è –≥–∏–±—Ä–∏–¥–Ω–æ–≥–æ —Ñ–æ—Ä–º–∞—Ç–∞)
            messageToDecrypt.addEventListener('input', function() {
                const value = this.value.trim();
                if (!value) {
                    this.style.borderColor = '#e1e8ed';
                    return;
                }
                const hexPart = value.startsWith('h1') ? value.slice(2) : value;
                if (!/^(h1)?[0-9a-fA-F]*$/.test(value)) {
                    this.style.borderColor = '#e74c3c';
                    return;
                }
                if (hexPart.length % 2 !== 0) {
                    this.style.borderColor = '#f39c12'; // –æ—Ä–∞–Ω–∂–µ–≤—ã–π - –Ω–µ–ø–æ–ª–Ω—ã–π –±–∞–π—Ç
                    return;
                }
                this.style.borderColor = '#e1e8ed';
            });
            
            // –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞ –ø—Ä–∏ –ø–µ—Ä–µ–∑–∞–≥—Ä—É–∑–∫–µ
            messageToEncrypt.addEventListener('input', debounce(saveTextState, 500));
            messageToDecrypt.addEventListener('input', debounce(saveTextState, 500));
        }
        
        // –ü–æ–∫–∞–∑–∞—Ç—å –ø–æ–ª–µ –≤—ã–±–æ—Ä–∞ —Ñ–∞–π–ª–∞
        function showFileInput() {
            pasteKeysContainer.style.display = 'none';
            fileInputContainer.style.display = 'block';
            keyFileInput.value = '';
            showMessage('–í—ã–±–µ—Ä–∏—Ç–µ —Ñ–∞–π–ª —Å –∫–ª—é—á–∞–º–∏ –≤ —Ñ–æ—Ä–º–∞—Ç–µ JSON', 'warning');
        }
        
        // –ü–æ–∫–∞–∑–∞—Ç—å –ø–æ–ª–µ –¥–ª—è –≤—Å—Ç–∞–≤–∫–∏ –∫–ª—é—á–µ–π
        function showPasteKeysInput() {
            fileInputContainer.style.display = 'none';
            pasteKeysContainer.style.display = 'block';
            pastePrivateKeyInput.value = '';
            pastePublicKeyInput.value = '';
            setTimeout(() => {
                pastePrivateKeyInput.focus();
                pastePrivateKeyInput.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }, 100);
        }
        
        // –°–∫—Ä—ã—Ç—å –ø–æ–ª–µ –¥–ª—è –≤—Å—Ç–∞–≤–∫–∏ –∫–ª—é—á–µ–π
        function hidePasteKeysInput() {
            pasteKeysContainer.style.display = 'none';
            pastePrivateKeyInput.value = '';
            pastePublicKeyInput.value = '';
        }
        
        // –ü—Ä–∏–º–µ–Ω–∏—Ç—å –≤—Å—Ç–∞–≤–ª–µ–Ω–Ω—ã–µ –∫–ª—é—á–∏
        async function applyPastedKeys() {
            const privateKeyBase64 = pastePrivateKeyInput.value.trim();
            const publicKeyBase64 = pastePublicKeyInput.value.trim();
            
            if (!privateKeyBase64 || !publicKeyBase64) {
                showMessage('‚ùå –í–≤–µ–¥–∏—Ç–µ –æ–±–∞ –∫–ª—é—á–∞ (–ø—Ä–∏–≤–∞—Ç–Ω—ã–π –∏ –ø—É–±–ª–∏—á–Ω—ã–π)', 'error');
                return;
            }
            
            try {
                applyPastedKeysBtn.disabled = true;
                await importKeysFromData(privateKeyBase64, publicKeyBase64);
                hidePasteKeysInput();
                showMessage('‚úÖ –ö–ª—é—á–∏ —É—Å–ø–µ—à–Ω–æ –ø—Ä–∏–º–µ–Ω–µ–Ω—ã –∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã');
            } catch (error) {
                showMessage('‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–∏–º–µ–Ω–µ–Ω–∏–∏ –∫–ª—é—á–µ–π: ' + error.message, 'error');
            } finally {
                applyPastedKeysBtn.disabled = false;
            }
        }
        
        // –û–±—Ä–∞–±–æ—Ç—á–∏–∫ –≤—ã–±–æ—Ä–∞ —Ñ–∞–π–ª–∞
        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            
            reader.onload = async (e) => {
                try {
                    const fileContent = e.target.result;
                    const keysData = JSON.parse(fileContent);
                    
                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç—Ä—É–∫—Ç—É—Ä—É —Ñ–∞–π–ª–∞
                    if (!keysData.privateKey || !keysData.publicKey) {
                        throw new Error('–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —Ñ–∞–π–ª–∞. –§–∞–π–ª –¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å –ø—Ä–∏–≤–∞—Ç–Ω—ã–π –∏ –ø—É–±–ª–∏—á–Ω—ã–π –∫–ª—é—á–∏.');
                    }
                    
                    // –ò–º–ø–æ—Ä—Ç–∏—Ä—É–µ–º –∫–ª—é—á–∏
                    await importKeysFromData(keysData.privateKey, keysData.publicKey);
                    fileInputContainer.style.display = 'none';
                    pasteKeysContainer.style.display = 'none';
                    showMessage('‚úÖ –ö–ª—é—á–∏ —É—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω—ã –∏–∑ —Ñ–∞–π–ª–∞');
                } catch (error) {
                    console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –∫–ª—é—á–µ–π –∏–∑ —Ñ–∞–π–ª–∞:', error);
                    showMessage('‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –∫–ª—é—á–µ–π –∏–∑ —Ñ–∞–π–ª–∞: ' + error.message, 'error');
                    keyFileInput.value = ''; // –°–±—Ä–æ—Å –¥–ª—è –ø–æ–≤—Ç–æ—Ä–Ω–æ–π –ø–æ–ø—ã—Ç–∫–∏ –≤—ã–±–æ—Ä–∞ —Ñ–∞–π–ª–∞
                }
            };
            
            reader.onerror = () => {
                showMessage('‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —á—Ç–µ–Ω–∏–∏ —Ñ–∞–π–ª–∞', 'error');
                keyFileInput.value = '';
            };
            
            reader.readAsText(file);
        }
        
        // –ò–º–ø–æ—Ä—Ç –∫–ª—é—á–µ–π –∏–∑ –¥–∞–Ω–Ω—ã—Ö
        async function importKeysFromData(privateKeyBase64, publicKeyBase64) {
            try {
                // –£–±–∏—Ä–∞–µ–º –ø—Ä–æ–±–µ–ª—ã –∏ –ø–µ—Ä–µ–Ω–æ—Å—ã (–º–æ–≥—É—Ç –±—ã—Ç—å –ø—Ä–∏ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–∏ –∏–ª–∏ –≤ JSON)
                const cleanPrivate = (privateKeyBase64 || '').replace(/\s/g, '');
                const cleanPublic = (publicKeyBase64 || '').replace(/\s/g, '');
                if (!cleanPrivate || !cleanPublic) {
                    throw new Error('–ö–ª—é—á–∏ –Ω–µ –º–æ–≥—É—Ç –±—ã—Ç—å –ø—É—Å—Ç—ã–º–∏.');
                }
                const privateKeyData = base64ToArrayBuffer(cleanPrivate);
                const publicKeyData = base64ToArrayBuffer(cleanPublic);
                
                cryptoKeys = {
                    privateKey: await window.crypto.subtle.importKey(
                        "pkcs8",
                        privateKeyData,
                        {
                            name: "RSA-OAEP",
                            hash: "SHA-256"
                        },
                        true,
                        ["decrypt"]
                    ),
                    publicKey: await window.crypto.subtle.importKey(
                        "spki",
                        publicKeyData,
                        {
                            name: "RSA-OAEP",
                            hash: "SHA-256"
                        },
                        true,
                        ["encrypt"]
                    )
                };
                
                // –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤ localStorage
                await saveKeys();
                await updateKeyDisplay();
                updateUI();
                
            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –∏–º–ø–æ—Ä—Ç–µ –∫–ª—é—á–µ–π:', error);
                throw new Error('–ù–µ —É–¥–∞–ª–æ—Å—å –∏–º–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å –∫–ª—é—á–∏. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ —Ñ–æ—Ä–º–∞—Ç —Ñ–∞–π–ª–∞.');
            }
        }
        
        // Debounce –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏
        function debounce(func, wait) {
            let timeout;
            return function executedFunction(...args) {
                const later = () => {
                    clearTimeout(timeout);
                    func(...args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        }
        
        // –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Å–æ—Å—Ç–æ—è–Ω–∏—è —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö –ø–æ–ª–µ–π (–ø—Ä–æ–ø—É—Å–∫ –ø—Ä–∏ –æ–±—ä—ë–º–µ > 500 –ö–ë)
        function saveTextState() {
            try {
                const state = {
                    messageToEncrypt: messageToEncrypt.value,
                    messageToDecrypt: messageToDecrypt.value
                };
                const str = JSON.stringify(state);
                if (str.length > 500 * 1024) return; // –ù–µ —Å–æ—Ö—Ä–∞–Ω—è—Ç—å –±–æ–ª—å—à–∏–µ –¥–∞–Ω–Ω—ã–µ
                localStorage.setItem('rsaTextState', str);
            } catch (e) {
                console.warn('–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ç–µ–∫—Å—Ç:', e);
            }
        }
        
        // –ó–∞–≥—Ä—É–∑–∫–∞ —Å–æ—Å—Ç–æ—è–Ω–∏—è —Ç–µ–∫—Å—Ç–æ–≤—ã—Ö –ø–æ–ª–µ–π
        function loadTextState() {
            try {
                const state = JSON.parse(localStorage.getItem('rsaTextState'));
                if (state) {
                    messageToEncrypt.value = state.messageToEncrypt || '';
                    messageToDecrypt.value = state.messageToDecrypt || '';
                }
            } catch (e) {
                console.warn('–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Å–æ—Å—Ç–æ—è–Ω–∏–µ —Ç–µ–∫—Å—Ç–∞:', e);
            }
        }
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ UI –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç —Å–æ—Å—Ç–æ—è–Ω–∏—è
        function updateUI() {
            const hasKeys = cryptoKeys !== null;
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Å—Ç–∞—Ç—É—Å–∞ –∫–ª—é—á–µ–π
            if (hasKeys) {
                keyStatusIndicator.className = 'status-indicator status-ready';
                keyStatusText.textContent = '–ö–ª—é—á–∏ –∑–∞–≥—Ä—É–∂–µ–Ω—ã –∏ –≥–æ—Ç–æ–≤—ã –∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é';
                keyStatusText.style.color = '#27ae60';
            } else {
                keyStatusIndicator.className = 'status-indicator status-not-ready';
                keyStatusText.textContent = '–ö–ª—é—á–∏ –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω—ã';
                keyStatusText.style.color = '#e74c3c';
            }
            
            // –ê–∫—Ç–∏–≤–∞—Ü–∏—è/–¥–µ–∞–∫—Ç–∏–≤–∞—Ü–∏—è –∫–Ω–æ–ø–æ–∫
            encryptBtn.disabled = !hasKeys;
            decryptBtn.disabled = !hasKeys;
            exportKeysBtn.disabled = !hasKeys;
            
            // –í–∏–∑—É–∞–ª—å–Ω–∞—è –æ–±—Ä–∞—Ç–Ω–∞—è —Å–≤—è–∑—å
            encryptBtn.title = hasKeys ? '' : '–°–Ω–∞—á–∞–ª–∞ –∑–∞–≥—Ä—É–∑–∏—Ç–µ –∏–ª–∏ —Å–≥–µ–Ω–µ—Ä–∏—Ä—É–π—Ç–µ –∫–ª—é—á–∏';
            decryptBtn.title = hasKeys ? '' : '–°–Ω–∞—á–∞–ª–∞ –∑–∞–≥—Ä—É–∑–∏—Ç–µ –∏–ª–∏ —Å–≥–µ–Ω–µ—Ä–∏—Ä—É–π—Ç–µ –∫–ª—é—á–∏';
        }
        
        // –ü–æ–∫–∞–∑–∞—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ
        function showMessage(text, type = 'success') {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${type}`;
            messageDiv.textContent = text;
            messageArea.appendChild(messageDiv);
            
            // –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —É–¥–∞–ª–∏—Ç—å —Å–æ–æ–±—â–µ–Ω–∏–µ —á–µ—Ä–µ–∑ 5 —Å–µ–∫—É–Ω–¥
            setTimeout(() => {
                if (messageDiv.parentNode) {
                    messageDiv.style.opacity = '0';
                    messageDiv.style.transition = 'opacity 0.3s';
                    setTimeout(() => {
                        if (messageDiv.parentNode) {
                            messageDiv.remove();
                        }
                    }, 300);
                }
            }, 5000);
        }
        
        // –ö–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ –≤ –±—É—Ñ–µ—Ä –æ–±–º–µ–Ω–∞ (—Ä–∞–±–æ—Ç–∞–µ—Ç –Ω–∞ –º–æ–±–∏–ª—å–Ω—ã—Ö)
        function copyToClipboard(text) {
            if (navigator.clipboard && window.isSecureContext) {
                navigator.clipboard.writeText(text).catch(() => fallbackCopy(text));
            } else {
                fallbackCopy(text);
            }
        }
        function fallbackCopy(text) {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.left = '-9999px';
            textArea.style.top = '0';
            textArea.setAttribute('readonly', '');
            document.body.appendChild(textArea);
            textArea.select();
            textArea.setSelectionRange(0, text.length);
            try {
                document.execCommand('copy');
            } catch (e) {
                console.warn('–ö–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ –Ω–µ —É–¥–∞–ª–æ—Å—å:', e);
            }
            document.body.removeChild(textArea);
        }
        
        // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –∫–ª—é—á–µ–π
        async function generateKeys() {
            try {
                generateLoader.style.display = 'inline-block';
                generateKeysBtn.disabled = true;
                
                cryptoKeys = await window.crypto.subtle.generateKey(
                    {
                        name: "RSA-OAEP",
                        modulusLength: 2048,
                        publicExponent: new Uint8Array([0x01, 0x00, 0x01]),
                        hash: "SHA-256"
                    },
                    true,
                    ["encrypt", "decrypt"]
                );
                
                await saveKeys();
                await updateKeyDisplay();
                updateUI();
                
                showMessage('‚úÖ –ö–ª—é—á–∏ —É—Å–ø–µ—à–Ω–æ —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω—ã –∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã');
            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∫–ª—é—á–µ–π:', error);
                showMessage('‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –∫–ª—é—á–µ–π: ' + error.message, 'error');
            } finally {
                generateLoader.style.display = 'none';
                generateKeysBtn.disabled = false;
            }
        }
        
        // –°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –∫–ª—é—á–µ–π –≤ –ª–æ–∫–∞–ª—å–Ω–æ–µ —Ö—Ä–∞–Ω–∏–ª–∏—â–µ
        async function saveKeys() {
            if (!cryptoKeys) return;
            
            try {
                const privateKeyData = await window.crypto.subtle.exportKey("pkcs8", cryptoKeys.privateKey);
                const publicKeyData = await window.crypto.subtle.exportKey("spki", cryptoKeys.publicKey);
                
                const privateKeyBase64 = arrayBufferToBase64(privateKeyData);
                const publicKeyBase64 = arrayBufferToBase64(publicKeyData);
                
                localStorage.setItem('rsaPrivateKey', privateKeyBase64);
                localStorage.setItem('rsaPublicKey', publicKeyBase64);
                
                console.log('–ö–ª—é—á–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã –≤ localStorage');
            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ –∫–ª—é—á–µ–π:', error);
                showMessage('‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ –∫–ª—é—á–µ–π: ' + error.message, 'error');
            }
        }
        
        // –ó–∞–≥—Ä—É–∑–∫–∞ –∫–ª—é—á–µ–π –∏–∑ –ª–æ–∫–∞–ª—å–Ω–æ–≥–æ —Ö—Ä–∞–Ω–∏–ª–∏—â–∞ (–ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ —Å—Ç—Ä–∞–Ω–∏—Ü—ã)
        async function loadFromStorage(silent = false) {
            try {
                const privateKeyBase64 = localStorage.getItem('rsaPrivateKey');
                const publicKeyBase64 = localStorage.getItem('rsaPublicKey');
                
                if (!privateKeyBase64 || !publicKeyBase64) {
                    if (!silent) {
                        showMessage('‚ÑπÔ∏è –ö–ª—é—á–∏ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã –≤ —Ö—Ä–∞–Ω–∏–ª–∏—â–µ. –°–Ω–∞—á–∞–ª–∞ —Å–≥–µ–Ω–µ—Ä–∏—Ä—É–π—Ç–µ –∏—Ö.', 'warning');
                    }
                    return;
                }
                
                await importKeysFromData(privateKeyBase64, publicKeyBase64);
                if (!silent) {
                    showMessage('‚úÖ –ö–ª—é—á–∏ —É—Å–ø–µ—à–Ω–æ –∑–∞–≥—Ä—É–∂–µ–Ω—ã –∏–∑ —Ö—Ä–∞–Ω–∏–ª–∏—â–∞');
                }
            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –∫–ª—é—á–µ–π:', error);
                showMessage('‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –∫–ª—é—á–µ–π: ' + error.message, 'error');
            }
        }
        
        // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –∫–ª—é—á–µ–π
        async function updateKeyDisplay() {
            if (!cryptoKeys) return;
            
            try {
                const privateKeyData = await window.crypto.subtle.exportKey("pkcs8", cryptoKeys.privateKey);
                const publicKeyData = await window.crypto.subtle.exportKey("spki", cryptoKeys.publicKey);
                
                const privateKeyBase64 = arrayBufferToBase64(privateKeyData);
                const publicKeyBase64 = arrayBufferToBase64(publicKeyData);
                
                privateKeyDisplay.textContent = formatKey(privateKeyBase64);
                publicKeyDisplay.textContent = formatKey(publicKeyBase64);
            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –∫–ª—é—á–µ–π:', error);
            }
        }
        
        // –§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–ª—é—á–∞ –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è
        function formatKey(keyBase64) {
            if (!keyBase64) return '';
            const matched = keyBase64.match(/.{1,64}/g);
            return matched ? matched.join('\n') : '';
        }
        
        // –®–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è
        async function encryptMessage() {
            if (!cryptoKeys) {
                showMessage('‚ùå –°–Ω–∞—á–∞–ª–∞ –∑–∞–≥—Ä—É–∑–∏—Ç–µ –∏–ª–∏ —Å–≥–µ–Ω–µ—Ä–∏—Ä—É–π—Ç–µ –∫–ª—é—á–∏', 'error');
                return;
            }
            
            const message = messageToEncrypt.value.trim();
            if (!message) {
                showMessage('‚ùå –í–≤–µ–¥–∏—Ç–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è', 'error');
                messageToEncrypt.focus();
                return;
            }
            
            // –õ–∏–º–∏—Ç 10 –ú–ë –¥–ª—è –≥–∏–±—Ä–∏–¥–Ω–æ–≥–æ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è
            const MAX_SIZE = 10 * 1024 * 1024; // 10 –ú–ë
            const encoder = new TextEncoder();
            const data = encoder.encode(message);
            const messageBytes = data.length;
            if (messageBytes > MAX_SIZE) {
                showMessage(`‚ùå –°–æ–æ–±—â–µ–Ω–∏–µ —Å–ª–∏—à–∫–æ–º –¥–ª–∏–Ω–Ω–æ–µ (${(messageBytes / 1024 / 1024).toFixed(1)} –ú–ë). –ú–∞–∫—Å–∏–º—É–º: 10 –ú–ë.`, 'error');
                messageToEncrypt.focus();
                return;
            }
            
            try {
                encryptLoader.style.display = 'inline-block';
                encryptBtn.disabled = true;
                
                let hexString;
                if (messageBytes <= 190) {
                    // –ö–æ—Ä–æ—Ç–∫–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è: —Ç–æ–ª—å–∫–æ RSA (—Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å —Å–æ —Å—Ç–∞—Ä—ã–º–∏)
                    const encrypted = await window.crypto.subtle.encrypt(
                        { name: "RSA-OAEP" },
                        cryptoKeys.publicKey,
                        data
                    );
                    hexString = arrayBufferToHexString(encrypted);
                } else {
                    // –î–ª–∏–Ω–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è: –≥–∏–±—Ä–∏–¥–Ω–æ–µ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ (AES-GCM + RSA)
                    hexString = await hybridEncrypt(data);
                }
                
                encryptedResult.textContent = hexString;
                
                if (autoCopyEnabled && hexString.length <= 500 * 1024) {
                    messageToDecrypt.value = hexString;
                    saveTextState();
                } else if (autoCopyEnabled && hexString.length > 500 * 1024) {
                    showMessage('–†–µ–∑—É–ª—å—Ç–∞—Ç —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–æ–π –¥–ª—è –∞–≤—Ç–æ-–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–Ω–æ–ø–∫—É –ö–æ–ø–∏—Ä–æ–≤–∞—Ç—å.', 'warning');
                }
                
                showMessage('‚úÖ –°–æ–æ–±—â–µ–Ω–∏–µ —É—Å–ø–µ—à–Ω–æ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–æ');
            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–∏:', error);
                showMessage('‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–∏: ' + error.message, 'error');
            } finally {
                encryptLoader.style.display = 'none';
                encryptBtn.disabled = !cryptoKeys;
            }
        }
        
        // –î–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è
        async function decryptMessage() {
            if (!cryptoKeys) {
                showMessage('‚ùå –°–Ω–∞—á–∞–ª–∞ –∑–∞–≥—Ä—É–∑–∏—Ç–µ –∏–ª–∏ —Å–≥–µ–Ω–µ—Ä–∏—Ä—É–π—Ç–µ –∫–ª—é—á–∏', 'error');
                return;
            }
            
            const encryptedHex = messageToDecrypt.value.trim();
            if (!encryptedHex) {
                showMessage('‚ùå –í–≤–µ–¥–∏—Ç–µ –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ', 'error');
                messageToDecrypt.focus();
                return;
            }
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ñ–æ—Ä–º–∞—Ç–∞: "h1" = –≥–∏–±—Ä–∏–¥–Ω—ã–π, –∏–Ω–∞—á–µ ‚Äî —Ç–æ–ª—å–∫–æ RSA
            const isHybrid = encryptedHex.startsWith('h1') && encryptedHex.length > 2;
            const dataHex = isHybrid ? encryptedHex.slice(2) : encryptedHex;
            
            if (!/^[0-9a-fA-F]+$/.test(dataHex)) {
                showMessage('‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ç–æ–ª—å–∫–æ hex-—Å–∏–º–≤–æ–ª—ã (0-9, a-f, A-F)', 'error');
                messageToDecrypt.focus();
                return;
            }
            if (dataHex.length % 2 !== 0) {
                showMessage('‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç. –î–ª–∏–Ω–∞ hex-—Å—Ç—Ä–æ–∫–∏ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å —á—ë—Ç–Ω–æ–π (–∫–∞–∂–¥—ã–π –±–∞–π—Ç = 2 —Å–∏–º–≤–æ–ª–∞)', 'error');
                messageToDecrypt.focus();
                return;
            }
            
            try {
                decryptLoader.style.display = 'inline-block';
                decryptBtn.disabled = true;
                
                let decrypted;
                if (isHybrid) {
                    decrypted = await hybridDecrypt(dataHex);
                } else {
                    const encryptedData = hexStringToArrayBuffer(dataHex);
                    decrypted = await window.crypto.subtle.decrypt(
                        { name: "RSA-OAEP" },
                        cryptoKeys.privateKey,
                        encryptedData
                    );
                }
                
                const decoder = new TextDecoder();
                const decryptedMessage = decoder.decode(decrypted);
                decryptedResult.textContent = decryptedMessage;
                
                showMessage('‚úÖ –°–æ–æ–±—â–µ–Ω–∏–µ —É—Å–ø–µ—à–Ω–æ —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∞–Ω–æ');
            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–∏:', error);
                showMessage('‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–∏: ' + error.message, 'error');
            } finally {
                decryptLoader.style.display = 'none';
                decryptBtn.disabled = !cryptoKeys;
            }
        }
        
        // –≠–∫—Å–ø–æ—Ä—Ç –∫–ª—é—á–µ–π
        async function exportKeys() {
            if (!cryptoKeys) {
                showMessage('‚ùå –ù–µ—Ç –∫–ª—é—á–µ–π –¥–ª—è —ç–∫—Å–ø–æ—Ä—Ç–∞', 'error');
                return;
            }
            
            try {
                const privateKeyData = await window.crypto.subtle.exportKey("pkcs8", cryptoKeys.privateKey);
                const publicKeyData = await window.crypto.subtle.exportKey("spki", cryptoKeys.publicKey);
                
                const privateKeyBase64 = arrayBufferToBase64(privateKeyData);
                const publicKeyBase64 = arrayBufferToBase64(publicKeyData);
                
                const exportData = {
                    privateKey: privateKeyBase64,
                    publicKey: publicKeyBase64,
                    timestamp: new Date().toISOString(),
                    format: 'RSA-OAEP 2048'
                };
                
                const blob = new Blob([JSON.stringify(exportData, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `rsa-keys-${new Date().toISOString().split('T')[0]}.json`;
                a.style.display = 'none';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                setTimeout(() => URL.revokeObjectURL(url), 100);
                
                showMessage('‚úÖ –ö–ª—é—á–∏ —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω—ã –≤ —Ñ–∞–π–ª');
            } catch (error) {
                console.error('–û—à–∏–±–∫–∞ –ø—Ä–∏ —ç–∫—Å–ø–æ—Ä—Ç–µ –∫–ª—é—á–µ–π:', error);
                showMessage('‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —ç–∫—Å–ø–æ—Ä—Ç–µ –∫–ª—é—á–µ–π: ' + error.message, 'error');
            }
        }
        
        // –û—á–∏—Å—Ç–∫–∞ –∫–ª—é—á–µ–π
        function clearKeys() {
            if (!confirm('–í—ã —É–≤–µ—Ä–µ–Ω—ã, —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ –æ—á–∏—Å—Ç–∏—Ç—å –≤—Å–µ –∫–ª—é—á–∏? –≠—Ç–æ –¥–µ–π—Å—Ç–≤–∏–µ –Ω–µ–ª—å–∑—è –æ—Ç–º–µ–Ω–∏—Ç—å.')) {
                return;
            }
            
            cryptoKeys = null;
            localStorage.removeItem('rsaPrivateKey');
            localStorage.removeItem('rsaPublicKey');
            localStorage.removeItem('rsaTextState');
            
            privateKeyDisplay.textContent = '–ö–ª—é—á –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω';
            publicKeyDisplay.textContent = '–ö–ª—é—á –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω';
            messageToEncrypt.value = '';
            messageToDecrypt.value = '';
            encryptedResult.textContent = '–ó–¥–µ—Å—å –±—É–¥–µ—Ç –æ—Ç–æ–±—Ä–∞–∂–µ–Ω —Ä–µ–∑—É–ª—å—Ç–∞—Ç —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è';
            decryptedResult.textContent = '–ó–¥–µ—Å—å –±—É–¥–µ—Ç –æ—Ç–æ–±—Ä–∞–∂–µ–Ω —Ä–µ–∑—É–ª—å—Ç–∞—Ç –¥–µ—à–∏—Ñ—Ä–æ–≤–∞–Ω–∏—è';
            fileInputContainer.style.display = 'none';
            hidePasteKeysInput();
            
            updateUI();
            showMessage('üóëÔ∏è –í—Å–µ –∫–ª—é—á–∏ –∏ –¥–∞–Ω–Ω—ã–µ –æ—á–∏—â–µ–Ω—ã');
        }
        
        // –í—Å–ø–æ–º–æ–≥–∞—Ç–µ–ª—å–Ω—ã–µ —Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è –∫–æ–Ω–≤–µ—Ä—Ç–∞—Ü–∏–∏
        function arrayBufferToBase64(buffer) {
            const bytes = new Uint8Array(buffer);
            let binary = '';
            for (let i = 0; i < bytes.byteLength; i++) {
                binary += String.fromCharCode(bytes[i]);
            }
            return btoa(binary);
        }
        
        function base64ToArrayBuffer(base64) {
            try {
                const binary = atob(base64);
                const bytes = new Uint8Array(binary.length);
                for (let i = 0; i < binary.length; i++) {
                    bytes[i] = binary.charCodeAt(i);
                }
                return bytes.buffer;
            } catch (e) {
                throw new Error('–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç Base64. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ, —á—Ç–æ –∫–ª—é—á —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω –ø–æ–ª–Ω–æ—Å—Ç—å—é.');
            }
        }
        
        function arrayBufferToHexString(buffer) {
            const bytes = new Uint8Array(buffer);
            let hex = '';
            for (let i = 0; i < bytes.length; i++) {
                const hexByte = bytes[i].toString(16).padStart(2, '0');
                hex += hexByte;
            }
            return hex;
        }
        
        function hexStringToArrayBuffer(hexString) {
            const bytes = new Uint8Array(hexString.length / 2);
            for (let i = 0; i < hexString.length; i += 2) {
                bytes[i / 2] = parseInt(hexString.slice(i, i + 2), 16);
            }
            return bytes.buffer;
        }
        
        // –ì–∏–±—Ä–∏–¥–Ω–æ–µ —à–∏—Ñ—Ä–æ–≤–∞–Ω–∏–µ: AES-GCM (–¥–∞–Ω–Ω—ã–µ) + RSA-OAEP (–∫–ª—é—á AES)
        async function hybridEncrypt(data) {
            const aesKey = await window.crypto.subtle.generateKey(
                { name: "AES-GCM", length: 256 },
                true,
                ["encrypt"]
            );
            const iv = crypto.getRandomValues(new Uint8Array(12));
            const encrypted = await window.crypto.subtle.encrypt(
                { name: "AES-GCM", iv: iv, tagLength: 128 },
                aesKey,
                data
            );
            const aesKeyRaw = await window.crypto.subtle.exportKey("raw", aesKey);
            const encryptedAesKey = await window.crypto.subtle.encrypt(
                { name: "RSA-OAEP" },
                cryptoKeys.publicKey,
                aesKeyRaw
            );
            return "h1" + arrayBufferToHexString(encryptedAesKey) + arrayBufferToHexString(iv) + arrayBufferToHexString(encrypted);
        }
        
        // –ì–∏–±—Ä–∏–¥–Ω–∞—è —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–∞
        async function hybridDecrypt(hexData) {
            const rsaEncryptedLen = 512;   // 256 –±–∞–π—Ç –≤ hex
            const ivLen = 24;              // 12 –±–∞–π—Ç –≤ hex
            if (hexData.length < rsaEncryptedLen + ivLen + 32) { // –º–∏–Ω–∏–º—É–º: –∫–ª—é—á + iv + 16 –±–∞–π—Ç tag
                throw new Error('–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö');
            }
            const rsaEncryptedHex = hexData.slice(0, rsaEncryptedLen);
            const ivHex = hexData.slice(rsaEncryptedLen, rsaEncryptedLen + ivLen);
            const cipherAndTagHex = hexData.slice(rsaEncryptedLen + ivLen);
            const aesKeyEncrypted = hexStringToArrayBuffer(rsaEncryptedHex);
            const aesKeyRaw = await window.crypto.subtle.decrypt(
                { name: "RSA-OAEP" },
                cryptoKeys.privateKey,
                aesKeyEncrypted
            );
            const aesKey = await window.crypto.subtle.importKey(
                "raw",
                aesKeyRaw,
                { name: "AES-GCM" },
                false,
                ["decrypt"]
            );
            const iv = hexStringToArrayBuffer(ivHex);
            const cipherAndTag = hexStringToArrayBuffer(cipherAndTagHex);
            return await window.crypto.subtle.decrypt(
                { name: "AES-GCM", iv: iv, tagLength: 128 },
                aesKey,
                cipherAndTag
            );
        }
        
        // –ó–∞–ø—É—Å–∫ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
        window.addEventListener('load', init);
    </script>
</body>
</html>